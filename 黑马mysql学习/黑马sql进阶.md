### MySql体系结构

<img src="images/image-20220920160136489.png">

#### 连接层

最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

#### 服务层

第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现， 如过程、函数等。
#### 引擎层
存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。
#### 存储层
主要是将数据存储在文件系统之上，并完成与存储引擎的交互。

### 存储引擎

> 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。

```sql
SHOW create table account;#查询该表的存储引擎

SHOW ENGINES;#查询当前数据库支持的存储引擎

CREATE TABLE my_myisam(
	id int,
	name VARCHAR(10)
)ENGINE = INNODB;#默认InnoDB
```

#### InnoDB

> InnoDB是一种兼顾 高可靠性和高性能的通用存储引擎，在MySQL 5.5之后，InnoDB是默认的MySQL存储引擎。

##### 特点

1. DML操作遵循ACID模型，支持事务;

2. 行级锁，提高并发访问性能;

3. 支持外键FOREIGN KEY约束，保证数据的完整性和正确性;

##### 文件

XXX.ibd: xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件， 存储该表的表结构(frm、 sdi) 、数据和索引。

参数: innodb_file_per_table#开启后一个表对应一个表空间，否则共享表空间

```sql
SHOW VARIABLES LIKE 'innodb_file_per_table';#NO
#我的Mysql版本 5.7.36
```

##### 逻辑存储结构

<img src="images/image-20220920180633379.png">

#### MyISAM

> MyISAM是MySql早期的默认存储引擎

##### 特点

不支持事务，不支持外键

支持表锁，不支持行锁

访问速度快

##### 文件

xxx.sdi: 存储表结构信息

xxx.MYD: 存储数据

xxx.MYI: 存储索引

#### Memory

> Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。

##### 特点

内存存放

hash索引( 默认)

##### 文件

xxx.sdi:存储表结构信息

<img src="images/image-20220920181712368.png">

#### 存储引擎选择

> 在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

**InnoDB:** 是Mysq|的默认存储引擎，**支持事务、外键**。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。

**MyISAM:** 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。（日志，评论）

**MEMORY:** 将所有数据保存在内存中，**访问速度快，通常用于临时表及缓存**。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。

### 索引

>索引(index) 是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法,这种数据结构就是索引。
>
>通俗来说，索引相当于目录，书签，它使人能够快速访问自己想要翻阅的内容。

#### 优点

1. 有索会提高数据检索的效率，降低数据库的I0成本；没有就会进行全表扫描效率低。

2. 通过索引对数据进行排序，降低数据排序成本，降低CPU消耗

#### 缺点

1. 索引列也是要占用空间的。

2. 索引大大提高了查询效率,同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。

#### 索引结构

##### B+Tree索引

最常见的索引类型，大部分引擎都支持B+树索引

##### Hash索引

底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询

##### R- tree(空间索引)

空间索引是MyISAM引擎的一个特殊索引类型， 主要用于地理空间数据类型，通常使用较少

##### Full-text(全文索引)

是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES

| 索引           | InnoDB          | MylSAM | Memory |
| -------------- | --------------- | ------ | ------ |
| **B+tree索引** | 支持            | 支持   | 支持   |
| Hash索引       | 不支持          | 不支持 | 支持   |
| R-tree索引     | 不支持          | 支持   | 不支持 |
| Full-text      | 5.6版本之后支持 | 支持   | 不支持 |

##### B树索引

<img src="images/images_20220921101634.png">

##### B+树

<img src="images/images_20220921103400.png">

与B树的区别：

1. 所有的数据都会出现在叶子节点
2. 叶子节点形成一个单向链表

##### MySql优化了B+Tree树

Mysql索引数据结构对经典的B+Tree进行了优化。在原B+树的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。（循环双向链表）

<img src="images/images_20220921104055.png">

##### Hash索引

哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。

<img src="images/images_20220921104516.png">

**特点**

1. Hash索 引只能用于对等比较(=，in)， 不支持范围查询(between, >，<，.. 

2. 无法利用索引完成排序操作

3. 查询效率高， 通常只需要一次检索就可以了，效率通常要高于B+tree索引

**存储引擎支持**

在MySQL中，支持hash索引的是Memory引擎，而InnoDB中 具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。

为什么InnoDB存储引擎选择使用B+tree索引结构?

1. 相对于二叉树，层级更少，搜索效率高，而且二叉树会退化为链表
2. 对于B-tree,无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据,只能增加树的高度，导致性能降低
3. 相对Hash索引，B+tree支持范围匹配及排序操作

#### 索引分类

| 分类     | 含义                                                 | 特点                     | 关键字   |
| -------- | ---------------------------------------------------- | ------------------------ | -------- |
| 主键索引 | 针对于表中主键创建的索引                             | 默认自动创建，只能有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个               | UNIQUE   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个               |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | FULLTEXT |

根据索引的存储形式进行分类

| 分类                      | 含义                                                       | 特点                |
| ------------------------- | ---------------------------------------------------------- | ------------------- |
| 聚集索引(Clustered Index) | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有,而且只有一个 |
| 二级索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个        |

**聚集索引选取规则:**

1. 如果存在主键，主键索引就是聚集索引。

2. 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引。

3. 如果表没有主键，或没有合适的唯一索引， 则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

**回表查询**：先走二级索引找到对应主键值，再根据主键值走聚集索引拿到对应的行数据（按B+Tree数查找方式）。

#### 思考题

1. 以下SQL语句，那个执行效率高?为什么?

```sql
select * from user where id= 10;#来自用户，其中id=10

select * from user where name= 'Arm';#从名称=‘Arm’的用户处选择

#备注: id为主键，name字段创建的有索引;
#第一句效率高，只需要查询聚集索引，而第二句需要进行回表查询
```

2. InnoDB主键索引的B+tree高度为多高呢?

#### 索引语法

**创建索引**

```sql
CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...);
```

**查看索引**

```sql
SHOW INDEX FROM table_name ;
```

**删除索引**

```sql
DROP INDEX index_name ON table_name;
```

#### SQL性能分析

##### SQL执行频率

MySQL客户端连接成功后，通过show [session|global] status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、 SELECT的访问频次:

```sql
SHOW GLOBAL STATUS LIKE 'Com_______';#哪些指令使用频繁，就优化哪条
```

##### 慢查询日志

慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位:秒，默认10秒)的所有SQL语句的日志。

MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件(/etc/my.cnf) 中配置如下信息: 

```sql
#开启MySQL慢日志查询开关
slow_query_log=1

#设置慢日志的时间为2秒，SQL 语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```

##### profile详情

show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数， 能够看到当前MySQL是否支持profile操作:

```sql
SELECT @@have_profiling;
```

默认profiling是关闭的，可以通过set语句在session/ global级别开启profiling：

```sql
show profile for query query_id;SELECT @@PROFILING#查看是否打开
SET profiling= 1;

show profiles;#查询当前会话执行的每一条sql语句耗时情况

show profile cpu for query query_id;#查询指定query_id的sql语句各个阶段的CPU耗时情况, 我的版本不支持
```

##### explain执行计划

EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。

语法：

```sql
#直接在select语句之前加上关键字explain/desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```

EXPLAIN执行计划各字段含义：

**Id**

select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下; id不同，值越大，越先执行)。

**select_type**

表示SELECT的类型，常见的取值有SIMPLE (简单表，即不使用表连接或者子查询)、PRIMARY (主查询，即外层的查询)、UNION (UNION中的第二个或者后面的查询语句)、SUBQUERY (SELECT/WHERE之后包含了子查询)等

**type**

表示连接类型，性能由好到差的连接类型为NULL、system、 const、 eq_ref、 ref、range、index、 all 。

**possible_key** 

显示可能应用在这张表上的索引，一个或多个。

**Key**

实际使用的索引，如果为NULL,则没有使用索引。

**Key_len** 

表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。

**rows**

MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。

**filtered**

表示返回结果的行数占需读取行数的百分比，filtered的值越大越好。